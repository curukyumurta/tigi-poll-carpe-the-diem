<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>TIGI A/B</title>
  <link rel="stylesheet" href="/style.css" />
</head>
<body>
  <div id="topbar">
    <div id="countdownWrap">
      <div id="countdown">--</div>
      <div id="timeBlocks"></div>
    </div>
  </div>

  <div id="level">LEVEL 1</div>

  <div id="stage">
    <div class="boxWrap">
      <div id="boxA" class="choiceBox">
        <canvas id="canvasA" class="canvasLayer"></canvas>
      </div>
      <div class="label">A</div>
    </div>

    <div class="boxWrap">
      <div id="boxB" class="choiceBox">
        <canvas id="canvasB" class="canvasLayer"></canvas>
      </div>
      <div class="label">B</div>
    </div>
  </div>

  <!-- ðŸ”´ SECRET OVERLAY -->
  <div id="secretOverlay" style="
    display:none;
    position:fixed;
    top:0; left:0; right:0; bottom:0;
    background:#000;
    z-index:999999;
    align-items:center;
    justify-content:center;
    padding:24px;
  ">
    <div id="secretText" style="
      color:#ff2b2b;
      text-align:center;
      font-size:22px;
      line-height:1.6;
      letter-spacing:2px;
      text-transform:uppercase;
      width:100%;
    ">KONTROL SENDE MI SANIYORSUN ?</div>
  </div>

  <!-- ðŸ™‚ TROLLFACE OVERLAY -->
  <div id="trollOverlay" style="
    display:none;
    position:fixed;
    top:0; left:0; right:0; bottom:0;
    background:#000;
    z-index:1000000;
    align-items:center;
    justify-content:center;
    padding:24px;
  ">
    <canvas id="trollCanvas" width="256" height="256" style="
      width:min(70vw, 320px);
      height:min(70vw, 320px);
      image-rendering:pixelated;
    "></canvas>
  </div>

  <!-- ðŸŸ¥ GAME OVER OVERLAY -->
  <div id="gameoverOverlay" style="
    display:none;
    position:fixed;
    top:0; left:0; right:0; bottom:0;
    background:#ff0000;
    z-index:1100000;
    align-items:center;
    justify-content:center;
    padding:24px;
  ">
    <div id="gameoverText" style="
      color:#000;
      text-align:center;
      font-size:28px;
      letter-spacing:3px;
      text-transform:uppercase;
      width:100%;
    ">OYUN BITTI</div>
  </div>

  <script type="module">
    import { io } from "https://cdn.socket.io/4.7.5/socket.io.esm.min.js";
    import { getPlayerId, GREENS, SFX, setupCanvas, clearCanvas, drawPixel, setLevelText, renderTimeBlocks } from "/common.js";

    const roomId = new URLSearchParams(location.search).get("room");
    if (!roomId) {
      document.body.innerHTML = "<div style='color:#fff;padding:24px'>room param yok. Ã–rnek: /player.html?room=ABC123</div>";
      throw new Error("Missing room");
    }

    const playerId = getPlayerId();
    const socket = io();

    const boxA = document.getElementById("boxA");
    const boxB = document.getElementById("boxB");
    const canvasA = document.getElementById("canvasA");
    const canvasB = document.getElementById("canvasB");
    const countdownEl = document.getElementById("countdown");
    const blocksEl = document.getElementById("timeBlocks");
    const levelEl = document.getElementById("level");

    const secretOverlay = document.getElementById("secretOverlay");
    const secretText = document.getElementById("secretText");

    const trollOverlay = document.getElementById("trollOverlay");
    const trollCanvas = document.getElementById("trollCanvas");
    const trollCtx = trollCanvas.getContext("2d");
    trollCtx.imageSmoothingEnabled = false;

    const gameoverOverlay = document.getElementById("gameoverOverlay");
    const gameoverText = document.getElementById("gameoverText");

    const ca = setupCanvas(canvasA);
    const cb = setupCanvas(canvasB);

    let phase = "IDLE";
    let endsAt = null;
    let votedThisRound = false;
    const TOTAL_MS = 10_000;

    function setDisabled(dis){
      boxA.classList.toggle("disabled", dis);
      boxB.classList.toggle("disabled", dis);
    }

    function resetVisual(){
      boxA.classList.remove("winnerA");
      boxB.classList.remove("winnerB");
      clearCanvas(ca.ctx, canvasA);
      clearCanvas(cb.ctx, canvasB);
      votedThisRound = false;
      setDisabled(true);
      countdownEl.textContent = "--";
      blocksEl.innerHTML = "";
    }

    function showWinner(winner){
      if (winner === "A") boxA.classList.add("winnerA");
      if (winner === "B") boxB.classList.add("winnerB");
    }

    function drawTrollFace(){
      const ctx = trollCtx;
      const W = trollCanvas.width;
      const H = trollCanvas.height;

      ctx.clearRect(0, 0, W, H);

      const grid = 16;
      const px = Math.floor(W / grid);
      const ON = "#ffffff";

      const p = [
        "0000000000000000",
        "0000011111100000",
        "0001110000111000",
        "0011000000001100",
        "0110001100110010",
        "0110011101110010",
        "1100000000000011",
        "1100000000000011",
        "1100000000000011",
        "1100100000001011",
        "0110010000010010",
        "0110001111100010",
        "0011000000001100",
        "0001110000111000",
        "0000011111100000",
        "0000000000000000",
      ];

      ctx.fillStyle = ON;
      for (let y = 0; y < grid; y++) {
        for (let x = 0; x < grid; x++) {
          if (p[y][x] === "1") ctx.fillRect(x * px, y * px, px, px);
        }
      }
    }

    boxA.addEventListener("click", async () => {
      if (phase !== "VOTING") return;
      if (votedThisRound) return;
      votedThisRound = true;
      setDisabled(true);
      await SFX.clickA();
      socket.emit("vote", { roomId, choice: "A", playerId });
    });

    boxB.addEventListener("click", async () => {
      if (phase !== "VOTING") return;
      if (votedThisRound) return;
      votedThisRound = true;
      setDisabled(true);
      await SFX.clickB();
      socket.emit("vote", { roomId, choice: "B", playerId });
    });

    socket.on("connect", () => {
      socket.emit("join", { roomId, role: "player" });
    });

    socket.on("state", (s) => {
      phase = s.phase;
      endsAt = s.endsAt;
      setLevelText(levelEl, s.level);
      if (phase === "IDLE") resetVisual();
      if (phase !== "VOTING") setDisabled(true);
    });

    socket.on("round_started", async ({ level, endsAt: ea }) => {
      phase = "VOTING";
      endsAt = ea;
      setLevelText(levelEl, level);
      votedThisRound = false;
      setDisabled(false);

      clearCanvas(ca.ctx, canvasA);
      clearCanvas(cb.ctx, canvasB);
      boxA.classList.remove("winnerA");
      boxB.classList.remove("winnerB");

      await SFX.roundStart();
    });

    socket.on("spawn", ({ choice, x, y, colorIndex }) => {
      const color = GREENS[colorIndex] || GREENS[1];
      const size = 8;
      if (choice === "A") drawPixel(ca.ctx, canvasA, { x01: x, y01: y, size, color });
      else drawPixel(cb.ctx, canvasB, { x01: x, y01: y, size, color });
    });

    socket.on("round_ended", ({ winner }) => {
      phase = "REVEAL";
      setDisabled(true);
      showWinner(winner);
    });

    socket.on("round_reset", ({ level }) => {
      phase = "IDLE";
      endsAt = null;
      setLevelText(levelEl, level);
      resetVisual();
    });

    // ðŸ”´ SECRET SCREEN
    socket.on("secret_screen", async ({ text }) => {
      secretText.textContent = text || "KONTROL SENDE MI SANIYORSUN ?";
      secretOverlay.style.display = "flex";
      secretOverlay.style.pointerEvents = "auto";
      setDisabled(true);

      await SFX.secretBuzz();

      setTimeout(() => {
        secretOverlay.style.display = "none";
      }, 2500);
    });

    // ðŸ™‚ TROLLFACE SCREEN
    socket.on("trollface_screen", async ({ durationMs }) => {
      drawTrollFace();
      trollOverlay.style.display = "flex";
      trollOverlay.style.pointerEvents = "auto";
      setDisabled(true);

      await SFX.plotSmile();

      const ms = typeof durationMs === "number" ? durationMs : 1800;
      setTimeout(() => {
        trollOverlay.style.display = "none";
      }, ms);
    });

    // ðŸŸ¥ OYUN BITTI SCREEN
    socket.on("gameover_screen", async ({ durationMs, text }) => {
      gameoverText.textContent = text || "OYUN BITTI";
      gameoverOverlay.style.display = "flex";
      gameoverOverlay.style.pointerEvents = "auto";
      setDisabled(true);

      await SFX.plotGameOver();

      const ms = typeof durationMs === "number" ? durationMs : 2000;
      setTimeout(() => {
        gameoverOverlay.style.display = "none";
      }, ms);
    });

    function tick(){
      if (phase === "VOTING" && endsAt){
        const rem = endsAt - Date.now();
        const sec = Math.max(0, Math.ceil(rem / 1000));
        countdownEl.textContent = String(sec).padStart(2, "0");
        renderTimeBlocks(blocksEl, rem, TOTAL_MS);
      }
      requestAnimationFrame(tick);
    }
    tick();

    socket.on("error_msg", (m) => alert(m));
  </script>
</body>
</html>
