<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>TIGI A/B</title>
  <link rel="stylesheet" href="/style.css" />
</head>
<body>
  <div id="topbar">
    <div id="countdownWrap">
      <div id="countdown">--</div>
      <div id="timeBlocks"></div>
    </div>
  </div>

  <div id="level">LEVEL 1</div>

  <div id="stage">
    <div class="boxWrap">
      <div id="boxA" class="choiceBox">
        <canvas id="canvasA" class="canvasLayer"></canvas>
      </div>
      <div class="label">A</div>
    </div>

    <div class="boxWrap">
      <div id="boxB" class="choiceBox">
        <canvas id="canvasB" class="canvasLayer"></canvas>
      </div>
      <div class="label">B</div>
    </div>
  </div>

  <!-- ðŸ”´ SECRET OVERLAY -->
  <div id="secretOverlay" style="
    display:none;
    position:fixed;
    top:0; left:0; right:0; bottom:0;
    background:#000;
    z-index:999999;
    align-items:center;
    justify-content:center;
    padding:24px;
  ">
    <div id="secretText" style="
      color:#ff2b2b;
      text-align:center;
      font-size:22px;
      line-height:1.6;
      letter-spacing:2px;
      text-transform:uppercase;
      width:100%;
    ">KONTROL SENDE MI SANIYORSUN ?</div>
  </div>

  <!-- ðŸ™‚ TROLLFACE OVERLAY -->
  <div id="trollOverlay" style="
    display:none;
    position:fixed;
    top:0; left:0; right:0; bottom:0;
    background:#000;
    z-index:1000000;
    align-items:center;
    justify-content:center;
    padding:24px;
  ">
    <canvas id="trollCanvas" width="256" height="256" style="
      width:min(70vw, 320px);
      height:min(70vw, 320px);
      image-rendering:pixelated;
    "></canvas>
  </div>

  <!-- ðŸŸ¥ GAME OVER OVERLAY -->
  <div id="gameoverOverlay" style="
    display:none;
    position:fixed;
    top:0; left:0; right:0; bottom:0;
    background:#ff0000;
    z-index:1100000;
    align-items:center;
    justify-content:center;
    padding:24px;
  ">
    <div id="gameoverText" style="
      color:#000;
      text-align:center;
      font-size:28px;
      letter-spacing:3px;
      text-transform:uppercase;
      width:100%;
    ">OYUN BITTI</div>
  </div>

  <!-- ðŸŒˆ GLITCH OVERLAY -->
  <div id="glitchOverlay" style="
    display:none;
    position:fixed;
    inset:0;
    background:#000;
    z-index:1200000;
    align-items:center;
    justify-content:center;
  ">
    <canvas id="glitchCanvas" style="
      width:100vw;
      height:100vh;
      image-rendering:pixelated;
    "></canvas>
  </div>

  <script type="module">
    import { io } from "https://cdn.socket.io/4.7.5/socket.io.esm.min.js";
    import { getPlayerId, GREENS, SFX, setupCanvas, clearCanvas, drawPixel, setLevelText, renderTimeBlocks } from "/common.js";

    const roomId = new URLSearchParams(location.search).get("room");
    if (!roomId) {
      document.body.innerHTML = "<div style='color:#fff;padding:24px'>room param yok. Ã–rnek: /player.html?room=ABC123</div>";
      throw new Error("Missing room");
    }

    const playerId = getPlayerId();
    const socket = io();

    const boxA = document.getElementById("boxA");
    const boxB = document.getElementById("boxB");
    const canvasA = document.getElementById("canvasA");
    const canvasB = document.getElementById("canvasB");
    const countdownEl = document.getElementById("countdown");
    const blocksEl = document.getElementById("timeBlocks");
    const levelEl = document.getElementById("level");

    const secretOverlay = document.getElementById("secretOverlay");
    const secretText = document.getElementById("secretText");

    const trollOverlay = document.getElementById("trollOverlay");
    const trollCanvas = document.getElementById("trollCanvas");
    const trollCtx = trollCanvas.getContext("2d");
    trollCtx.imageSmoothingEnabled = false;

    const gameoverOverlay = document.getElementById("gameoverOverlay");
    const gameoverText = document.getElementById("gameoverText");

    const glitchOverlay = document.getElementById("glitchOverlay");
    const glitchCanvas = document.getElementById("glitchCanvas");
    const glitchCtx = glitchCanvas.getContext("2d");
    glitchCtx.imageSmoothingEnabled = false;

    const ca = setupCanvas(canvasA);
    const cb = setupCanvas(canvasB);

    let phase = "IDLE";
    let endsAt = null;
    let votedThisRound = false;
    const TOTAL_MS = 10_000;

    function setDisabled(dis){
      boxA.classList.toggle("disabled", dis);
      boxB.classList.toggle("disabled", dis);
    }

    function resetVisual(){
      boxA.classList.remove("winnerA");
      boxB.classList.remove("winnerB");
      clearCanvas(ca.ctx, canvasA);
      clearCanvas(cb.ctx, canvasB);
      votedThisRound = false;
      setDisabled(true);
      countdownEl.textContent = "--";
      blocksEl.innerHTML = "";
    }

    function showWinner(winner){
      if (winner === "A") boxA.classList.add("winnerA");
      if (winner === "B") boxB.classList.add("winnerB");
    }

    function drawTrollFace(){
      const ctx = trollCtx;
      const W = trollCanvas.width;
      const H = trollCanvas.height;

      ctx.clearRect(0, 0, W, H);

      const grid = 16;
      const px = Math.floor(W / grid);
      const ON = "#ffffff";

      const p = [
        "0000000000000000",
        "0000011111100000",
        "0001110000111000",
        "0011000000001100",
        "0110001100110010",
        "0110011101110010",
        "1100000000000011",
        "1100000000000011",
        "1100000000000011",
        "1100100000001011",
        "0110010000010010",
        "0110001111100010",
        "0011000000001100",
        "0001110000111000",
        "0000011111100000",
        "0000000000000000",
      ];

      ctx.fillStyle = ON;
      for (let y = 0; y < grid; y++) {
        for (let x = 0; x < grid; x++) {
          if (p[y][x] === "1") ctx.fillRect(x * px, y * px, px, px);
        }
      }
    }

    function resizeGlitchCanvas(){
      const dpr = Math.min(window.devicePixelRatio || 1, 2);
      const w = Math.floor(window.innerWidth / 2);
      const h = Math.floor(window.innerHeight / 2);
      glitchCanvas.width = Math.floor(w * dpr);
      glitchCanvas.height = Math.floor(h * dpr);
      glitchCtx.setTransform(dpr, 0, 0, dpr, 0, 0);
    }
    window.addEventListener("resize", resizeGlitchCanvas);
    resizeGlitchCanvas();

    function hsvToRgb(h, s, v){
      let c = v * s;
      let x = c * (1 - Math.abs(((h / 60) % 2) - 1));
      let m = v - c;
      let r=0,g=0,b=0;
      if (h < 60) { r=c; g=x; b=0; }
      else if (h < 120) { r=x; g=c; b=0; }
      else if (h < 180) { r=0; g=c; b=x; }
      else if (h < 240) { r=0; g=x; b=c; }
      else if (h < 300) { r=x; g=0; b=c; }
      else { r=c; g=0; b=x; }
      return {
        r: Math.round((r+m)*255),
        g: Math.round((g+m)*255),
        b: Math.round((b+m)*255)
      };
    }

    function randColor(){
      const h = Math.random() * 360;
      const s = 0.85 + Math.random() * 0.15;
      const v = 0.75 + Math.random() * 0.25;
      const {r,g,b} = hsvToRgb(h, s, v);
      return `rgb(${r},${g},${b})`;
    }

    function drawGlitchFrame(){
      const w = glitchCanvas.getBoundingClientRect().width;
      const h = glitchCanvas.getBoundingClientRect().height;

      glitchCtx.clearRect(0, 0, w, h);
      glitchCtx.fillStyle = "#000";
      glitchCtx.fillRect(0, 0, w, h);

      const cell = 6;
      const snap = (n) => Math.floor(n / cell) * cell;

      // âœ… daha yoÄŸun: 80-140
      const shapes = 80 + Math.floor(Math.random() * 61);

      for (let i = 0; i < shapes; i++) {
        glitchCtx.fillStyle = randColor();

        const kind = Math.random();
        if (kind < 0.45) {
          const ww = snap(60 + Math.random() * 260);
          const hh = snap(6 + Math.random() * 28);
          const x = snap(Math.random() * (w - ww));
          const y = snap(Math.random() * (h - hh));
          glitchCtx.fillRect(x, y, ww, hh);
        } else if (kind < 0.8) {
          const s = snap(16 + Math.random() * 80);
          const x = snap(Math.random() * (w - s));
          const y = snap(Math.random() * (h - s));
          glitchCtx.fillRect(x, y, s, s);
        } else {
          const s = snap(6 + Math.random() * 18);
          const x = snap(Math.random() * (w - s));
          const y = snap(Math.random() * (h - s));
          glitchCtx.fillRect(x, y, s, s);
        }
      }

      const lines = 1 + Math.floor(Math.random() * 3);
      for (let i = 0; i < lines; i++) {
        glitchCtx.fillStyle = randColor();
        const y = snap(Math.random() * h);
        glitchCtx.fillRect(0, y, w, snap(2 + Math.random() * 6));
      }
    }

    async function runGlitch(frames = 10, frameMs = 200){
      glitchOverlay.style.display = "flex";
      glitchOverlay.style.pointerEvents = "auto";
      setDisabled(true);

      const totalDuration = frames * frameMs;

      // âœ… gÃ¶rÃ¼ntÃ¼ boyunca glitch bed
      const soundPromise = SFX.glitchBed(totalDuration);

      for (let i = 0; i < frames; i++){
        drawGlitchFrame();
        await new Promise(r => setTimeout(r, frameMs));
      }

      glitchOverlay.style.display = "none";
      await soundPromise;
    }

    // clicks
    boxA.addEventListener("click", async () => {
      if (phase !== "VOTING") return;
      if (votedThisRound) return;
      votedThisRound = true;
      setDisabled(true);
      await SFX.clickA();
      socket.emit("vote", { roomId, choice: "A", playerId });
    });

    boxB.addEventListener("click", async () => {
      if (phase !== "VOTING") return;
      if (votedThisRound) return;
      votedThisRound = true;
      setDisabled(true);
      await SFX.clickB();
      socket.emit("vote", { roomId, choice: "B", playerId });
    });

    socket.on("connect", () => {
      socket.emit("join", { roomId, role: "player" });
    });

    socket.on("state", (s) => {
      phase = s.phase;
      endsAt = s.endsAt;
      setLevelText(levelEl, s.level);
      if (phase === "IDLE") resetVisual();
      if (phase !== "VOTING") setDisabled(true);
    });

    socket.on("round_started", async ({ level, endsAt: ea }) => {
      phase = "VOTING";
      endsAt = ea;
      setLevelText(levelEl, level);
      votedThisRound = false;
      setDisabled(false);

      clearCanvas(ca.ctx, canvasA);
      clearCanvas(cb.ctx, canvasB);
      boxA.classList.remove("winnerA");
      boxB.classList.remove("winnerB");

      await SFX.roundStart();
    });

    socket.on("spawn", ({ choice, x, y, colorIndex }) => {
      const color = GREENS[colorIndex] || GREENS[1];
      const size = 8;
      if (choice === "A") drawPixel(ca.ctx, canvasA, { x01: x, y01: y, size, color });
      else drawPixel(cb.ctx, canvasB, { x01: x, y01: y, size, color });
    });

    socket.on("round_ended", ({ winner }) => {
      phase = "REVEAL";
      setDisabled(true);
      showWinner(winner);
    });

    socket.on("round_reset", ({ level }) => {
      phase = "IDLE";
      endsAt = null;
      setLevelText(levelEl, level);
      resetVisual();
    });

    // overlays
    socket.on("secret_screen", async ({ text }) => {
      secretText.textContent = text || "KONTROL SENDE MI SANIYORSUN ?";
      secretOverlay.style.display = "flex";
      secretOverlay.style.pointerEvents = "auto";
      setDisabled(true);

      await SFX.secretBuzz();

      setTimeout(() => {
        secretOverlay.style.display = "none";
      }, 2500);
    });

    socket.on("trollface_screen", async ({ durationMs }) => {
      drawTrollFace();
      trollOverlay.style.display = "flex";
      trollOverlay.style.pointerEvents = "auto";
      setDisabled(true);

      await SFX.plotSmile();

      const ms = typeof durationMs === "number" ? durationMs : 1800;
      setTimeout(() => {
        trollOverlay.style.display = "none";
      }, ms);
    });

    socket.on("gameover_screen", async ({ durationMs, text }) => {
      gameoverText.textContent = text || "OYUN BITTI";
      gameoverOverlay.style.display = "flex";
      gameoverOverlay.style.pointerEvents = "auto";
      setDisabled(true);

      await SFX.plotGameOver();

      const ms = typeof durationMs === "number" ? durationMs : 2000;
      setTimeout(() => {
        gameoverOverlay.style.display = "none";
      }, ms);
    });

    socket.on("glitch_screen", async ({ frames, frameMs }) => {
      const f = typeof frames === "number" ? frames : 10;
      const ms = typeof frameMs === "number" ? frameMs : 200;
      await runGlitch(f, ms);
    });

    function tick(){
      if (phase === "VOTING" && endsAt){
        const rem = endsAt - Date.now();
        const sec = Math.max(0, Math.ceil(rem / 1000));
        countdownEl.textContent = String(sec).padStart(2, "0");
        renderTimeBlocks(blocksEl, rem, TOTAL_MS);
      }
      requestAnimationFrame(tick);
    }
    tick();

    socket.on("error_msg", (m) => alert(m));
  </script>
</body>
</html>
